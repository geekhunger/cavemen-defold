function init(self)
	-- TODO: loop only through tilemap portion currently visible, not the whole map!
	
	local tilemap_tile_width = 8
	local tilemap_tile_height = 8
	local curr_pos = go.get_position("/fallower")
	local curr_scale = go.get_scale_vector("/world")
	local tilemap_x,
		  tilemap_y,
		  tilemap_width,
		  tilemap_height = tilemap.get_bounds("/map#tilemap")
	
	-- NOTE
	-- Tilemap has a special layer "characters" which get replaced by real spawn gameobjects
	-- Define a dictionary like {[tile_id] = factory}
	
	local player_list = {
		["8"]  = "hero",
		["24"] = "guard",
		["40"] = "ork"
	}
	
	for i = 1, tilemap_width do
		for j = 1, tilemap_height do
			-- NOTE
			-- tilemap_x and tilemap_y begins with (1,1) at world origin (0,0)
			-- One tile to the left would be at (0,1), next at (-1,1), and so on (same applies for y)
			-- This means we can not simply loop from tilemap_x to tilemap.width (same on height) since we would get wrong tile positions
			
			local x = i + tilemap_x - 1
			local y = j + tilemap_y - 1
			local tile_id  = tilemap.get_tile("/map#tilemap", "characters", x, y)
			local tile_x = (x * tilemap_tile_width - tilemap_tile_width/2 - curr_pos.x) * curr_scale.x
			local tile_y = (y * tilemap_tile_height - tilemap_tile_height/2 - curr_pos.y) * curr_scale.y
			local player = player_list[tostring(tile_id)]
			
			if player then
				if player == "hero" then
					msg.post("/fallower#controller", "set_position", {x = tile_x, y = tile_y})
				else
					factory.create("#"..player, vmath.vector3(tile_x, tile_y, go.get_position("/player").z))
				end
			end
		end
	end
end

function final(self)
end

function update(self, dt)
end

function on_message(self, message_id, message, sender)
end

function on_input(self, action_id, action)
end

function on_reload(self)
end
